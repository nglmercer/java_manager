class n{constructor(t,s){this._subscribers=new Set,this._value=t,this._computeFn=s,s&&(this._computedDependencies=new Set,this._trackDependencies())}get value(){return i.trackSignal(this),this._value}set value(t){if(this._computeFn)throw new Error("Cannot set value of a computed signal");if(this._value!==t){const s=this._value;this._value=t,this._notify(t,s)}}subscribe(t){return this._subscribers.add(t),t(this._value,this._value),()=>{this._subscribers.delete(t)}}_notify(t,s){for(const r of this._subscribers)r(t,s)}_trackDependencies(){if(!(!this._computeFn||!this._computedDependencies)){i.startTracking();try{this._value=this._computeFn()}finally{const t=i.stopTracking();for(const s of t)s._subscribers.add(()=>this._recompute()),this._computedDependencies.add(s)}}}_recompute(){if(!this._computeFn)return;const t=this._value;this._value=this._computeFn(),t!==this._value&&this._notify(this._value,t)}}class i{static{this._tracking=!1}static{this._dependencies=new Set}static trackSignal(t){this._tracking&&this._dependencies.add(t)}static startTracking(){this._tracking=!0,this._dependencies.clear()}static stopTracking(){this._tracking=!1;const t=new Set(this._dependencies);return this._dependencies.clear(),t}}function c(e){return new n(e)}function a(e){return new n(e(),e)}function o(e){e()}var u=window.$signals={store:new Map,create(e,t){const s=c(t);return this.store.set(e,s),s},get(e){return this.store.get(e)},computed(e,t){const s=a(t);return this.store.set(e,s),s},batch(e){o(e)},subscribe(e,t){const s=this.store.get(e);if(!s)throw new Error(`Signal "${e}" not found`);return s.subscribe(t)},set(e,t){const s=this.store.get(e);if(!s)throw new Error(`Signal "${e}" not found`);s.value=t}};const h=window.$signals.create("tabs",{});export{u as s,h as t};
